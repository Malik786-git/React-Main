---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
                                                 React Fragment
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
(Ref file App.js to index.js)
Fragment is used to group a list of children without adding extra nodes to the DOM

Example:
<React.Fragment>
<h1>Hello world</h1>      
</React.Fragment>

Also Fragment use key attribute;
<React.Fragment key={id}>
<h1>{item.title}</h1>      
<p>{item.description}</p>      
</React.Fragment>


----------------------------------------------------------------------------------
Function Component;
It is a JS function which accepts a single "props" object argument with data and return a React Element..



function fun1(props) {
    return <h1>Hello</h1>
}

const fun1  =  (props) => <h1>Hello {props.name}</h1>


----------------------------------------------------------------------------------

Class Component
A class Component required you to extend from React.Component. The class must implement a render() member
function which return a React Component to be rendered, similar to a return value of a function Component. 
In a class-based Component, props are accessible via this.props.

class App extends Component {
    render(){
        return <h1>Hello </h1>
    }
}



----------------------------------------------------------------------------------
Rendering a Component; (ref Student.js)


ReactDOM.render(<Student/>, document.getElementById('root'));
ReactDOM.render(<Student name="malik"/>, document.getElementById('root'));

example...  

function Studnet(props) {
    return <h1>Hello {props.name}</h1>
}
ReactDOM.render(<Student name="malik"/>, document.getElementById('root'));

Note: yha per Studnet Component me jo name attribute hy, jab ReactDOM.render isy run kare ga tu name ki value 
      is Component ke props me bhej dega.


-----------------------------------------------------------------------------------
ref Teacher.js to App.js to index.js

Composing Component (use same Component for multiple value)
Component can refer to other Component in their output. This lets us use the same Component abstraction for any level of detail.


function Teacher(props) {
    return <h1>Hello {props.name}</h1>
}


function App(){
    return (
        <div>
              <Teacher/>
              <Teacher/>
              <Teacher/>
        </div>
    )
}

ReactDOM.render(<App/>, document.getElementById('root'));

here ReactDom render App-component and App render 3 component of Teacher 

--------------------------------------------------------------------------------------------

Function vs Class Component;


*Use function components if you are waiting a presentational component which doesn't have it own states or needs to access
a lifecycle hook. You cannot use setState() in your component because Function Components are plain JavaScript Function.

*Use class Component if you need state or need to access lifecycle hook because all lifecycle hooks are coming from the React.
Component which you extend from in class components.


---------------------------------------------------------------------------------------------
Ref JSXElement to indus.js


JavaScript Expression In JSX 

we can put any valid JavaScript Expression inside the curly braces in JSX. You can pass any JavaScript Expression as children, 
by enclosing it within {}.
example..

*const A = <h1>Sum = {10+20}</h1>

* const name = "malik"
*const A = <h1>{name}</h1>



----------------------------------------------------------------------------------------

Specifying attribute with JSX.

<h1 className = "bg">Hello world</h1>
<h1 htmlFor= "name" >Hello world</h1>
<h1 className =  {ac.tab} >Hello world</h1>

-----------------------------------------------------------------------------------------
ref props.js to index.js
PROPS.....

When React sees an element representing a user-define  component, it pass JSX attribute to this component as a single object. 
We call this object "props".

function Teacher(props) {
    return <h1>Hello {props.name} and {props.id}</h1>
}

ReactDOM.render(<Teacher name="malik" id="101" />, document.getElementById('root'));
ReactDOM.render(<Teacher name="malik" id={100+1} />, document.getElementById('root'));
ReactDOM.render(<Teacher name={"malik"} id=100 />, document.getElementById('root'));


Check type of props data. (npmjs.com prop-type)
install > npm install prop-types

To use props type import first;
import PropTypes from 'prop-types';

Student.propTypes = {

    name: PropTypes.string,
    ArrayData: PropTypes.array,
    FunctionData: PropTypes.func,
    Number: PropTypes.number,
    object: PropTypes.object,
    symbol: PropTypes.symbol

}



----------------------------------------------------------------------------------------------
JSXchild.js to index.js
JSX children.....

In JSX Expression that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop.
props.children

example...
<Student>Im a child<Studnet/>



--------------------------------------------------------------------------------------------------------
State... (ref: state.js to index.js)
It is similar to props, but it is provate and fully controlled by the component. We can create state only in class component. It is possible to update the state/Modify the state.

How to initialize state in React Component:-
*Directly inside class
class Studnet extends Component {
    state = {
        name:"malik",
        age: this.prop.age
    }
    render(){
        ....
    }
}



*Inside the constructor
we use constructor to write state, because constructor call first automatically and initialize the value in memory.


class Studnet extends Component {
    constructor(props){
        // in constructor super must call, it is required to call the parent class constructor.
        super(props)
        this.state = {
            name: "malik",
           age: this.prop.age
        }
    }
    render(){
        ....
    }
}

-----------------------------------------------------------------------------------------------------
Events... (ref event.js to index.js)
Handling events with React element is very similar to Handling events on DOM elements. There are some syntactic difference.
ReactEvent are names using camelCase
With JSX you pass a function as the event handler, rather than a string.

Example..

In html;

<button onclick="fun()">Submit</button>

In React;
<button onClick={fun}>Submit</button> //function Component
<button onClick={this.fun}>Submit</button> //class Component


--------------------------------------------------------------
retrn false;


You cannot return false to prevent default behavior in React. You must call preventDefault explicitly.

In html;
    <a href="https://www.google.com/" onclick="console.log('hello a'); return false">Click Here</a>

In React;

function handlerClick(e){
    e.preventDefault();
}
    <a href="https://www.google.com/" onclick={handlerClick}>Click Here</a>



------------------------------------------------------------------------------------------------------------
update State....

setState() method is used to update states.

this.state = {
    name:"malik"
}

// take argument as a object;               
this.setState({name:"jahangir"});

// take argument as a function;

this.setState(function(state, props){
    return ...
});

------------------------------------------------------------------------------------------------------------
Passing argument to Events handler. (ref: Eventargu.js to indux)



<button onClick={(e)=> this.fun(id,e)}>Delete</button>
or
<button onClick={this.fun(this,id)}>Delete</button>

Note: In both cases, the e argument representing the React event will be passed as a second argument after the ID.




-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
                          Phases of Component... (Mounting, Updating,Error, Unmounting)
-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------


this lifecycle method use only in class based component...

Mounting - Mounting is the process of creating an element and inserting it in a DOM tree.
Methods are used to create and inserted into the DOM.
* constructor() ref(mounting.js to index.js)
    initialize local state by assigning an object to this.state
    Ex:- this.State = {name:"malik"}
    Binding event handler method to an instance
    Ex:- this.fun = this.fun(this);

    note: constructor first call..


* static getDerivedStateFromProps() ref(mounting.js to mount.js to index.js)
    this is invoked right before calling the render method, both on the initial mount and on subsequent updates. 
    It should return an object to update the state, or null to update nothing. This method exists for rare use cases
    where the state depends on the changes in props over time. This method doesnot have access to the component instance.
    syntax: static getDerivedStateFromProps(props, state){...  };

    note: getDerivedStateFromProps second call after constructor call..
* render()
    simple run parent child hierarchy.

* componentDidMount()
    componentDidMount is invoked immediately after a component is mounted (insert into the tree), after the render()
    method has taken place.
    This is where AJAX  requests and DOM or state update sould occur. This method is also used for integration with other JS
    frameworks and any function with delayed execution such as setTimeout or setInterval.

    Api call sould be made in componentDidMount method always.
    get data from server and set the data to state.

    Note: it call last after whole app render.

     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Updating - Updating is the process of changing state or props of component and update change to nodes already in the DOM.
     Updating Method...
          *statis getDerivedStateFromProps() (ref: updating.js to update.js to index.js)
          
          *sholdComponentUpdate() (same ref above)
          this is invoked before rendering when new props and state are being received. THis method return true by default.
          Syntax: shouldComponentUpdate(nextProps, nextState) {... }
              
          *render()
          *getSnapshortBeforeUpdate()
          This method is called right before the virtual DOM is about to make change to the DOM (before DOM is updated). 
         

          *componentDidUpdate()
          Jo capture huta hy getSnapshortBeforeUpdate method me wo third parameter hume componentDidUpdate method me milta hy.

          This method is used  to re trigger the third party libraries used to make sure these libraries also update and reload thmselves.
          -componentDidUpdate will not be invoked if should sholdComponentUpdate() return false.
          if not return any thing as a third parameter, so it return undefine.

     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Error Handling(optional phase) - These are used when there is error during rendering, in lifecycle method or in the constructor of any component.
     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Unmounting - Unmounting is the process of removing components from the DOM.
               (ref: unmounting.js to unmount.js to index.js and index.html root= stu)
               componentWillUnmount() before component is unmounted and destroyed it call.
               before removing the component in DOM.



-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
                                        HOOKS in React
-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
Hooks are function that let you "hook  into" React state and lifecycle features from function component.
React provides a few built in Hooks like useState, useEffect etc.
Hooks are a new addition in React 16.8

When use Hooks
If you write a function component and realize you need to add some state to it.



Rules Of Hooks..........
*Only call Hooks at the top level - We should not call Hooks inside loops, conditions, or nested functions.
Instead, always use Hooks at the top level of your React Function.

*Only call Hooks from React function - We should not call Hooks from regular JavaScript functions. Instead, call
Hooks from React function components or cell Hooks from custom Hooks.

*React relies on the order in which Hooks are called.

*Hooks don't work inside class.


-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
                                     useState Hook (builting hooks)
-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
ref useStae.js to index.js
useState() - useState is a hook that allows you add React state to function component. We call it inside a 
function component to add some local state to it.
useState reaturns a pair -  the current state value and a function that lets you update it.
React will preserve this state between re-renders
You can call this function from an event handler  or somewhere else.

Ex
import React, {useState} from 'react';
useState('malik'); // we now it return two things one is current state and second function, so we assign it in a variable.

const abc = useState('malik');
const x = abc[0]; const y = abc[1]; we assing current state in x and function in y;


or best way using destructing....
const [x, y] = useState('malik');

function App(){
    const [x, y] = useState('malik');
    const [x, y] = useState(101);
    const [x, y] = useState([{sub:"math"}]);

    .....

}

Now Accessing State...
example:

const [name, funName] = useState('malik');

  accessing name and funName....

<h1>Your Name is {name}</h1>

Updating State:

funName('malik');



------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
                                     useEffect Hook (builting hooks)
-------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
ref useEffect.js to index.js
useEffect is a hook for encapsulating code that has 'side effects,' if you re familiar with Ract class lifecycle
methods, you can think of useEffect Hook as componentDidMount, componentDidUpdate, and componentWillUnmount combined.
import React, {useStae, useEffect} from 'react';
useEffect(Function)
useEffect(Function, Array) //here array argu is optional.

Note: the function passed to useEffect will run after the render is committed to the screen. 
      Second argument to useEffect that is the array of values that the effect depends on.


     useEffect(()=>{
         console.log('hello world')
     }); 

     useEffect(()=>{
         console.log('hello world')
     }, [count]); 

By usring this Hook, you tell React that your component needs to do something after render. React will remember the function
you passed and call it later after performong the DOM updates. In this effect, we set the document title, we could also perform
data fetching or call some other imperative API.

By default, it runs both after the first render and after every update.




------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
                                      Custom Hook 
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
ref: customHook2.js to customHook.js to index.js

A custom Hook is a js function whose name stars with 'use' and that may call other hook.
function useSomething(){
    return ....
}

const data = useSomething();

























